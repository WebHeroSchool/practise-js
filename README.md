### 1. Используйте === вместо == 
В JavaScript существует два разных типа операций сравнения: === / !== и == / !=. Считается хорошим тоном всегда использовать первую пару для сравнения.

>“Если два операнда одного типа и значения, то === вернет true, а !== false”
>>JavaScript: The Good Parts

### 2. Уменьшите количество глобальных переменных

>«Сведением количества глобальных переменных к одному, вы значительно снижаете шансы нежелательного взаимодействия с другими приложениями, виджетами или библиотеками.»
>>— Douglas Crockford


```
var name = 'Jeffrey';  
var lastName = 'Way';  
  
function doSomething() {...}  
  
console.log(name); // Jeffrey -- or window.name 


var nameSpace = {  
   name : 'Jeffrey',  
   lastName : 'Way',  
   doSomething : function() {...}  
}  
console.log(nameSpace.name); // Jeffrey 

```
### 3. Не передавайте строку в «SetInterval» или «SetTimeOut»
Создание массива через использование квадратных скобок более читабельная запись.
Сравните:
```
setInterval(  
"document.getElementById('container').innerHTML += 'My new number: ' + i", 3000  
);  
```
Вместо этого передавайте функцию в качестве аргумента.

```
setInterval(someFunction, 3000);  
```
### 4. Для создания объекта используйте фигурные скобки {}. Не создавайте объекты через конструктор new Object.

```
// плохо
const item = new Object();

// хорошо
const item = {};
```

### 5. Для создания массива используйте квадратные скобки []. Не создавайте массивы через конструктор new Array.

```
// плохо
var items = new Array();

// хорошо
var items = [];
```

### 6. Переместите скрипты вниз страницы
Основная цель этой практики — заставить страницу грузиться как можно быстрее. Когда браузер грузит скрипт он не продолжит рендеринг пока весь файл не будет загружен. Таким образом пользователю придется ждать дольше.
Если ваши JS скрипты служать для добавления функционала — например, обработки кликов кнопки то вам стоит перенести скрипты вниз поставив их перед закрывающимся тегом body.

```
<p>And now you know my favorite kinds of corn. </p>  
<script type="text/javascript" src="path/to/file.js"></script>  
<script type="text/javascript" src="path/to/anotherFile.js"></script>  
</body>  
</html>
```

### 7. Длинный список переменных? Опустите "let"/"const" и используйте запятые

```
let someItem = 'some string';  
let anotherItem = 'another string';  
let oneMoreItem = 'one more string';  
```
Лучше:
```
let someItem = 'some string',  
  anotherItem = 'another string',  
  oneMoreItem = 'one more string'; 
```
### 8. Не игнорируйте основание системы счисления при использовании функции parseInt

В JavaScript есть хорошая удобная функция parseInt, которая позволяет конвертировать строку, содержащую число в значение числового типа.
```
parseInt("200"); // 200
parseInt("043"); // 35

```
Разве во второй строке должно быть не 43?
В действительности parseInt работает не только с десятичной системой счисления, поэтому, когда функция "видит" строку, начинающуюся с нуля, то она считает, что имеет дело с числом в восьмеричной системе счисления.
Вот почему нужно передавать данной функции второй параметр - необходимую систему счисления:
```
parseInt("020", 10); // 20
parseInt("100", 2);  // 4
```

### 9. Шаблонные строки 
Используя шаблонные строки, мы можем спокойно использовать в строках специальные символы.


```
var name = 'Miron';
var age = 13;

console.log('My cat is named ' + name + ' and is ' + age + ' years old.');
}
```
Гораздо проще:

```
const name = 'Miron';
const age = 13;

console.log(`My cat is named ${name} and is ${age} years old.`);
```

### 10. Не используйте короткую запись

Технически можно писать код без фигурных скобок и точек с запятой. Большинство браузеров корректно воспримет следующий код:

```
if(someVariableExists)  
  x = false  
  anotherFunctionCall();  
```
Кто-то может посчитать что это эквивалентно следующему:

```
if(someVariableExists) {  
  x = false;  
  anotherFunctionCall();  
}  
```
И он будет неправ. Потому что на самом деле для компилятора это выглядит так:
```
if(someVariableExists) {  
  x = false;  
}  
anotherFunctionCall(); 
```
Как вы заметили отступ маскирует функционал фигурных скобок. Излишне говорить, что это ужасная практика, которую следует избегать любой ценой. Единственное где вы можете опустить использование скобок это в однострочных выражениях, но даже это вызывает кучу споров.